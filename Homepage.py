# AUTOGENERATED! DO NOT EDIT! File to edit: AccidentBcn.ipynb.

# %% auto 0
__all__ = []

# %% AccidentBcn.ipynb 4
from datetime import datetime

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from datetime import datetime
import streamlit as st
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score,mean_squared_error
import  pandas as pd
import  numpy as np
import time
import warnings
warnings.filterwarnings('ignore')
import streamlit.components.v1 as components
import base64

# ----- Page configs -----
st.set_page_config(
        page_title = "Fallou Fall Portfolio" ,
        page_icon = "üß™" ,
        )

# ----- Left menu -----
with st.sidebar :
    st.image("eae_img.png" , width = 200)
    st.write(
            """He indagat en un ampli conjunt de dades d'accidents de vehicles a Barcelona, Catalunya. Mitjan√ßant una an√†lisi meticulos, he desvet differents patrons temporals i espacials, he pogut identificar factors clau que contribueixen als accidents, i desenvolupar models predictius que ajuden a preveure futurs accidents. Les meves troballes proporcionen valuosos coneixements per a responsables de pol√≠tiques i urbanistes, orientant els esfor√ßos per millorar les mesures de seguretat del tr√†nsit i mitigar els riscos. En √∫ltima inst√†ncia, aquest recorregut exemplifica el poder de la ci√®ncia de dades en impulsar canvis socials positius i fomentar comunitats ¬†m√©s ¬†segures.""")
    st.write(
            "Les dades extretes de: https://opendata-ajuntament.barcelona.cat/data/es/dataset/accidents_causa_conductor_gu_bcn/resource/5a040155-38b3-4b19-a4b0-c84a0618d363/download/2023_accidents_causa_conductor_gu_bcn_.csv")

# ----- Title of the page -----

st.title("üöñ Accident a Barcelona 2023  üöñ")
@st.cache_data
def load_data() :
    try :
        url = "https://opendata-ajuntament.barcelona.cat/data/es/dataset/accidents_causa_conductor_gu_bcn/resource/5a040155-38b3-4b19-a4b0-c84a0618d363/download/2023_accidents_causa_conductor_gu_bcn_.csv"
        df = pd.read_csv(url , index_col = False)
    except FileNotFoundError :
        st.error("Error: Data file not found. Please check the path.")

    return df  #


df = load_data()


with st.expander("Check the complete dataset:") :
    st.dataframe(df.head(15))



st.subheader("Accidents a Barcelona ")
px.set_mapbox_access_token("pk.eyJ1Ijoic25vd21hbjIxIiwiYSI6ImNsdW9ueHU1MjA3NzUyaXI5bTV3NXlja3AifQ.Q3KozS09j8cSaQs-hMHgQQ")


fig = px.scatter_mapbox(df, lat='Latitud_WGS84', lon='Longitud_WGS84',
                        color_continuous_scale=px.colors.qualitative.Light24,
                        zoom=11, height=600,width = 800)
fig.update_layout(mapbox_style="open-street-map")
fig.update_layout(title='Cluster accidents per Zona')
st.plotly_chart(fig)
st.divider()




st.divider()
st.subheader("Barri amb m√©s Accidents")

with st.container() :
    barrio = df['Nom_barri'].value_counts().nlargest(30).sort_values(ascending = True)
    fig = px.bar(x = barrio.values , y = barrio.index , orientation = 'h' , width = 800 , height = 600 ,
            labels = { 'x' : 'Accident' , 'y' : 'TOP Barri' } ,
            title = 'Top 20  Barris amb m√©s Accidents' ,
            color = barrio.index , color_continuous_scale = ['deepskyblue'] * len(barrio.index) ,
            color_discrete_sequence = px.colors.qualitative.Pastel * len(barrio.index) ,
            )
st.plotly_chart(fig)
st.divider()




st.subheader("Causa")
top_N = 10
top_causes = df['Descripcio_causa_mediata'].value_counts().nlargest(top_N)
colors = px.colors.qualitative.Pastel[:top_N]

color_map = {category: color for category, color in zip(top_causes.index, colors)}
fig = px.histogram(df[df['Descripcio_causa_mediata'].isin(top_causes.index)],
                   x='Descripcio_causa_mediata',
                   title=f"Top {top_N} Causes",
                   height=650, width=800,
                   color='Descripcio_causa_mediata',
                   color_discrete_map=color_map)
st.plotly_chart(fig)



st.divider()
st.subheader("Horari amb  m√©s Accidents")
with st.container() :
    horaire = df['Hora_dia'].value_counts().sort_index()
    colors = px.colors.qualitative.Pastel[:len(horaire)]
    color_map = { category : color for category , color in zip(horaire.index , colors) }

    # Create the bar chart
    fig = px.bar(x = horaire.index , y = horaire.values ,
            labels = { 'x' : 'Horari' , 'y' : 'Accident' } ,
            title = 'Dia i hora amb amb m√©s Accidents' ,
            height = 600 , width = 800 ,
            color_discrete_sequence = colors)  # Using color_discrete_sequence

st.plotly_chart(fig)



st.divider()
st.subheader("Mes amb  m√©s Accidents")
mes_count = df['Nom_mes'].value_counts().sort_index()
colors = px.colors.qualitative.Pastel[:len(mes_count)]
color_map = {category: color for category, color in zip(mes_count.index, colors)}

fig = px.bar(x=mes_count.index, y=mes_count.values,
             labels={'x': 'Nom_mes', 'y': 'Accident'},
             title='Mes amb  m√©s Accidents',
             height=600, width=800,
             color=mes_count.index,
             color_discrete_map=color_map)
st.plotly_chart(fig)





st.divider()
st.subheader("Quan hi han m√©s Accidents")
turnover_counts = df['Descripcio_torn'].value_counts()
colors = px.colors.qualitative.Pastel[:len(turnover_counts)]
# Create pie chart
fig = px.pie(values=turnover_counts.values,
             names=turnover_counts.index,
             title='Quan hi han m√©s Accidents',
             color_discrete_sequence=colors,
             hole=0.3)
st.plotly_chart(fig)







#i calculate the number of accident for each district and add it to the dataframe
df['district_appearance'] = df.groupby('Codi_districte')['Codi_districte'].transform('count')



#model k mean
data = df[['Longitud_WGS84', 'Latitud_WGS84']]
scaler = StandardScaler()
scaled_data = scaler.fit_transform(data)
k = 5
kmeans = KMeans(n_clusters=k, random_state=42)
kmeans.fit(scaled_data)

#distotion calculation
coords = df[['Longitud_WGS84','Latitud_WGS84']]
distortions = []
K = [1,2,3,4,5]
for k in K:
    kmeansModel = KMeans(n_clusters=k)
    kmeansModel = kmeansModel.fit(coords)
    distortions.append(kmeansModel.inertia_)






st.divider()
st.subheader("Model de distorsi√≥")
fig = go.Figure()
fig.add_trace(go.Scatter(
    x=K,
    y=distortions,
    mode='lines+markers',  # Combined line and markers mode
    marker=dict(
    size=8,  # Adjust marker size as desired
    )
))

fig.update_layout(
    title='M√®tode del colze per a k √≤ptim',
    xaxis_title='k',
    yaxis_title='Distorsi√≥',
    width=800,
    height=600,
)
st.plotly_chart(fig)
st.divider()





st.subheader("Cluster d'accidents per Zona")
df['cluster'] = kmeans.labels_
fig = px.scatter_mapbox(df, lat='Latitud_WGS84', lon='Longitud_WGS84', color='cluster',
                        color_continuous_scale=px.colors.qualitative.Light24,
                        zoom=10, height=600,width = 800)
fig.update_layout(mapbox_style="open-street-map")
fig.update_layout(title='Cluster accidents per Zona')
st.plotly_chart(fig)





#Soulouhete cal
kmeans = KMeans(n_clusters=5, init='k-means++')
kmeans.fit(coords)
y = kmeans.labels_
#print("k = 5", " silhouette_score ", silhouette_score(coords, y, metric='euclidean'))


#predict the cluster based on localisation
df['cluster'] = kmeans.predict(df[['Longitud_WGS84','Latitud_WGS84']])


def drivesafe( df , longitude , latitude ) :
    cluster = kmeans.predict(np.array([longitude , latitude]).reshape(1 , -1))[0]
    return df[df['cluster'] == cluster].iloc[0 :5][
        ['Nom_carrer' , 'Nom_barri' , 'Latitud_WGS84' , 'Longitud_WGS84' , 'cluster']]




longitude=df['Longitud_WGS84']
latitude=df['Latitud_WGS84']
longitude =st.selectbox(' Longitud', longitude)
latitude =st.selectbox(' Latitud', latitude)


st.markdown(
    """
    <style>
    .stButton>button {
        background-color: red;
        color:#ffffff
    }
    </style>
    """,
    unsafe_allow_html=True
)
if st.button('Preveure'):
    prediction = drivesafe(df,longitude,latitude)
    score=pd.DataFrame(prediction)
    fig = go.Figure()


    fig.add_trace(
            go.Scattermapbox(
                    lat = df["Latitud_WGS84"] ,
                    lon = df["Longitud_WGS84"] ,
                    mode = "markers" ,
                    marker = dict(
                            size = 8 ,
                            color = 'red'
                            ) ,
                    name = "Accident anterior"
                    )
            )


    fig.add_trace(
            go.Scattermapbox(
                    lat = [latitude] ,
                    lon = [longitude] ,
                    mode = "markers" ,
                    marker = dict(
                            size = 20 ,
                            color = 'green'
                            ) ,
                    name = " La meva posici√≥"
                    )
            )

    # Update the layout
    fig.update_layout(
            mapbox = dict(
                    style = "carto-positron" ,
                    center = dict(
                            lat = latitude ,
                            lon = longitude
                            ) ,
                    zoom = 13
                    ) ,
            width = 800 ,
            height = 600
            )
    st.plotly_chart(fig)
    st.markdown(
            f'<div style="background-color: lightgreen; padding: 10px; font-size: 25px;display: flex; align-items: center; width:400,justify-content: center;text-align:center;">‚ö†Ô∏è  Nivell de vigil√†ncia al voltant de ‚ö†Ô∏è </div>' ,
            unsafe_allow_html = True)
    score



